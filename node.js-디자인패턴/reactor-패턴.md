# Reactor 패턴

## 블로킹 I/O, 논블로킹 I/O

* 디스크나 네트워크로의 I/O는 CPU의 처리 속도에 비해 느리다.
* 이렇게 많은 시간이 걸리는 작업을 CPU가 마냥 기다리게 되면 다른 작업의 처리가 늦어진다.
* 스레드나 프로세스를 여러개 생성하는 식으로 블로킹으로 인한 지연 시간을 줄여 동시성을 개선할 수 있지만, CPU의 유휴 시간이 낭비된다.
* CPU의 유휴 시간을 줄이기 위한 바쁜 대기라는 전통적인 해결책도 있지만, 이 역시 감시할 이벤트가 없을 때 조차 대기를 지속한다는 점에서 비효율적이다.

## Event Demultiplexer (또는 이벤트 통지 인터페이스) 패턴

* I/O 요청이 들어오면 이벤트 디멀티플렉서가 호출된다.
* 호출된 디멀티플렉서는 요청을 큐에 수집한 뒤, 작업을 처리한다.
* 수집된 요청이 처리될 때까지 이벤트 루프는 차단된다.
* 요청이 처리되면 디멀티플렉서가 완료 이벤트를 반환하고 이벤트 루프가 핸들러를 실행한다.
* 모든 핸들러의 실행이 끝나면, 이벤트 루프는 디멀티플렉서가 반환하는 새로운 완료 이벤트가 있을 때까지 차단된다.

## Reactor 패턴 소개

* 애플리케이션에 I/O 작업이 발생하면 디멀티플렉서를 호출한다. (동기)
* 호출된 디멀티플렉서는 작업이 완료되면 실행할 핸들러를 이벤트 큐에 추가하고 즉시 제어를 애플리케이션에 반환한다. (비동기)
* 디멀티플렉서가 작업을 완료하면 이벤트 루프는 이벤트 큐를 순회하면서 핸들러를 실행한다.
  * 핸들러가 실행되면 제어권은 이벤트 루프로 넘어간다.
  * 이벤트 큐를 순회하며 핸들러를 하나씩 처리하던 중, 애플리케이션에 새로운 I/O 작업이 발생하면 제어를 애플리케이션에 넘기고 다시 디멀티플렉서를 기다린다.
* 모든 핸들러가 실행되면, 디멀티플렉서의 작업이 완료될 때까지 이벤트 루프는 차단된다.

## libuv

* 비동기를 처리하는 방식에는 OS 간 차이가 있다.
* 모든 플랫폼에서 동일한 동작이 가능하도록 하는 로우레벨 라이브러리.

## Node.js의 구조

* 코어 자바스크립트 API (자바스크립트로 구현된 노드의 API)
* 바인딩 (로우레벨 API를 자바스크립트로 사용할 수 있도록 래핑)
* V8 & libuv (가장 아래 위치함)
