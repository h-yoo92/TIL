# 관찰자 패턴

* 관찰자 패턴은 리액터, 콜백, 모듈 패턴과 더불어 노드의 주된 디자인 패턴이다.
* 연속 전달 스타일(CPS)과 다르게 *상태 변화*가 일어날 때 리스너에게 알릴 수 있는 객체를 정의한다.

## EventEmitter 클래스

* 노드의 코어에 이미 내장되어 있어 `EventEmitter` 클래스로부터 인스턴스를 생성하거나 그 기능을 확장하는 방식으로 바로 사용할 수 있다.
* `EventEmitter` 는 아래의 메서드를 제공한다. (더 많은 API는 [공식 문서](https://nodejs.org/api/events.html)를 참고)
  * `on(eventName, listener)` : 이벤트 리스너를 등록함. 체이닝을 지원하기 위해 자기를 반환. 이미 등록되었는지는 신경쓰지 않기 때문에 특정 이벤트에 동일 리스너를 중복해서 등록하면 리스너가 여러번 실행됨!
  * `once(eventName, listener)` : 한번 호출된 후 삭제되는 리스너를 등록함. 체이닝을 지원하기 위해 자기를 반환.
  * `emit(eventName[, ...args])` : 이벤트를 발생시키고 관찰자들에게 값(옵셔널)을 전달. 해당 이벤트에 리스너가 등록되어 있으면 `true` 를 반환.
  * `removeListener(eventName, listener)` : 해당 이벤트의 리스너 목록에서 특정 리스너를 제거함. 체이닝을 지원하기 위해 자기를 반환.

## 오류 전파

* 이벤트 루프에서 발생한 에러는 바로 `throw` 할 수 없다.
* 따라서 규약에 의해 `'error'` 이벤트를 전파해 `Error` 객체를 전달한다.

## 관찰 가능한 객체

* `EventEmitter` 클래스로부터 인스턴스를 생성하는 방식은 단순히 이벤트를 전파하는 기능 이상을 제공하기 어렵다.
* 그래서 보통은 `EventEmitter` 를 상속받아 기능을 확장하는 방식을 사용한다.
  * 내장 HTTP 모듈과 스트림이 이런 방식을 적극적으로 활용

## 동기 및 비동기 이벤트

* 비동기적으로 발생하는 이벤트는 관찰가능한 객체가 생성된 이후에 리스너를 등록할 수 있다.
  * 리스너는 동기적으로 등록되고, 비동기 작업이 완료되어 이벤트 루프에서 리스너를 실행할 때까지는 이벤트 루프가 차단되기 때문.
* 동기적으로 발생하는 이벤트는 경우에 따라서 리스너가 적절한 타이밍에 실행되지 못할 수 있다.
* 이벤트를 어떤 방식으로 발생하게 할 것인지는 상황에 따라 다를 수 있다. 따라서 이벤트의 동작을 명시하는 것이 좋다.

## EventEmitter vs 콜백

* 두 패턴 모두 비동기적으로 결과를 반환할 수 있다.
* 두 패턴 중 어떤 것을 사용할 것인지는 가독성, 의미, 구현 등을 고려해 결정한다.
* 정보의 전달이 결과의 반환보다 더 중요할 때는 `EventEmitter` 가 콜백에 비해 더 나은 선택일 수 있다.
  * 물론 여러 콜백을 받는 방식을 취할 수도 있지만 좋은 인터페이스라고 보긴 어렵다! (구현만 생각해봐도... 🤯)
  * 여러 수신자가 이벤트를 관찰해야 할 때도 `EventEmitter` 가 적절하다.
* 모듈 패턴에서 배운 것처럼 두 패턴을 모두 사용할 수도 있다.
  * 결과는 콜백으로 반환하고, 상태 변화는 이벤트로 알리면 관찰 가능한 객체의 의도를 더 잘 나타낼 수 있다.
